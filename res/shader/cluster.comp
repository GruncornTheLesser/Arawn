#version 450

struct AABB { // axis aligned bounding box
    vec4 min_point;
    vec4 max_point;
};
layout(std140, set = 2, binding = 0) buffer ClusterBuffer { // axis alligned bounding box
    AABB clusters[];
};
layout(std140, set = 1, binding = 2) buffer RenderData {
    mat4 inv_proj;
	uvec3 cluster_count;
	float bias;
	uvec2 screen_size;
	float near;
	float far;
};

vec3 intersect_depth(vec3 p, float z) {
    const vec3 normal = vec3(0, 0, 1);
    const vec3 a =      vec3(0, 0, 0);
    float t = (z - dot(normal, a)) / dot(normal, p);
    vec3 result = a + t * p;
    return result;
}

vec3 view_space(vec2 uv) {
    vec4 clip = vec4(uv.xy * 2.0 - 1.0, -1.0, 1.0);
    vec4 view = inv_proj * clip;
    view = view / view.w; // normalized
    return view.xyz;
}

layout(local_size_x = 1, local_size_y = 1) in; // 1 innvocation per work group

void main() {
    uint tile_index = gl_WorkGroupID.x + 
                      gl_WorkGroupID.y * gl_NumWorkGroups.x +
                      gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

    vec3 a = view_space((gl_WorkGroupID.xy          ) / gl_NumWorkGroups.xy); // top left
    vec3 b = view_space((gl_WorkGroupID.xy + vec2(1)) / gl_NumWorkGroups.xy); // bottom right

    float near_slice = -near * pow(far / near, (gl_WorkGroupID.z    ) / float(gl_NumWorkGroups.z));
    float far_slice  = -near * pow(far / near, (gl_WorkGroupID.z + 1) / float(gl_NumWorkGroups.z));

    vec3 p1 = intersect_depth(a, near_slice);
    vec3 p2 = intersect_depth(a, far_slice);
    vec3 p3 = intersect_depth(b, near_slice);
    vec3 p4 = intersect_depth(b, far_slice);

    clusters[tile_index].min_point  = vec4(min(min(p1, p2),min(p3, p4)), 0.0);
    clusters[tile_index].max_point  = vec4(max(max(p1, p2),max(p3, p4)), 0.0);
}