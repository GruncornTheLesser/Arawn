#version 460
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#define TILE_SIZE 16
#define MAX_LIGHTS_PER_TILE 127

const float PI      = 3.14;
const float EPSILON = 0.01;

struct Light { 
	vec3 position; // position + radius
	float radius;
	vec3 colour;
	float intensity; 
};

struct Frustum {
	vec4 planes[4];
};

struct Cluster {
	uint light_count;
	uint indices[MAX_LIGHTS_PER_TILE];
};

layout(std140, set=0, binding=0) uniform Camera {
    mat4 proj;
    mat4 view;
    mat4 inv_proj;
    uvec2 screen_size;
	float near;
	float far;
    vec3 eye;
};

layout(std430, set=1, binding=0) buffer Lights {
    uvec3 cluster_count;
    uint light_count;
    Light lights[];
};

layout(std430, set=1, binding=1) buffer Frustums {
	Frustum frustums[];
};

layout(std430, set=1, binding=2) buffer Clusters {
	Cluster clusters[]; // indices[0] = count;
};

layout(set=1, binding = 3) uniform sampler2D depth_sampler;


float linearize_depth(float depth) {
    return (near * far) / max(far - clamp(depth, 0, 1) * (far - near), EPSILON);
}

bool sphere_inside_plane(vec3 pos, float rad, vec4 plane) {
	return dot(plane.xyz, pos) - plane.w < -rad;
}

bool sphere_inside_frustum(Light light, Frustum frustum, float z_near, float z_far) {
	vec4 position = (view * vec4(light.position.xyz, 1));
	float z = -position.z;
	if (z + light.radius < z_near || z - light.radius > z_far) { 
		return false;
	}
	// if sphere insides Frustum plane
	if (sphere_inside_plane(position.xyz, light.radius, frustum.planes[0])) return false;
	if (sphere_inside_plane(position.xyz, light.radius, frustum.planes[1])) return false;
	if (sphere_inside_plane(position.xyz, light.radius, frustum.planes[2])) return false;
	if (sphere_inside_plane(position.xyz, light.radius, frustum.planes[3])) return false;
	
	return true;
}


layout (local_size_x=16, local_size_y=16) in;

shared uint subgroup_count;
shared float subgroup_z_min[64]; // 64 because smallest subgroup size == 4
shared float subgroup_z_max[64]; // 16x16/4 = 64

void main() {
	if (gl_GlobalInvocationID.x >= screen_size.x) return;
	if (gl_GlobalInvocationID.y >= screen_size.y) return;

	const float bias = 1.0;
	float depth = texelFetch(depth_sampler, ivec2(gl_GlobalInvocationID.xy), 0).r;
	
	if (gl_LocalInvocationID.xy == uvec2(0)) {
		atomicExchange(subgroup_count, 0);
	}
	
	depth = linearize_depth(depth);
	float z_min = subgroupMin(depth);
	float z_max = subgroupMax(depth);
	
	if (subgroupElect()) {
		uint index = atomicAdd(subgroup_count, 1);
		subgroup_z_min[index] = z_min;
		subgroup_z_max[index] = z_max;
	}

	if (gl_LocalInvocationID.xy == uvec2(0)) {
		uint workgroup_index = gl_WorkGroupID.x + 
						       gl_WorkGroupID.y * gl_NumWorkGroups.x;

		float z_min = subgroup_z_min[0];
		float z_max = subgroup_z_min[0];
		for (uint i = 1; i < subgroup_count; ++i) {
			z_min = min(z_min, subgroup_z_min[i]);
			z_max = max(z_max, subgroup_z_max[i]);
		}

		uint count = 0;
		for (uint light_index = 0; light_index < light_count; ++light_index) {
			if (sphere_inside_frustum(lights[light_index], frustums[workgroup_index], z_min, z_max)) { 
				clusters[workgroup_index].indices[count] = light_index;
				if (++count == MAX_LIGHTS_PER_TILE) {
					break;
				}
			}
		}

		clusters[workgroup_index].light_count = count;	
	}
}